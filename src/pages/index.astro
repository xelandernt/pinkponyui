---
import BaseHead from '../components/BaseHead.astro';
import Event from '../components/Event.astro';
import Footer from '../components/Footer.astro';
import { getCollection } from 'astro:content';
import {SITE_TITLE} from "../consts";

// Get all events from content collection and sort by order
const allEvents = await getCollection('events');
const sortedEvents = allEvents.sort((a, b) => (a.data.order ?? 0) - (b.data.order ?? 0));

// Render all events
const renderedEvents = await Promise.all(
	sortedEvents.map(async (event) => ({
		...event,
		Content: (await event.render()).Content
	}))
);
---

<!doctype html>
<html lang="en">
	<head>
		<BaseHead title={SITE_TITLE} description="Join the Pink Pony Running Club for running events and community fun!" />
	</head>
	<body>
		<!-- Hero/Cover Section -->
		<section class="hero">
			<div class="title-container">
				<h1 class="hero-title" id="hero-title">
					<span class="word">PINK</span>
					<span class="word">PONY</span>
					<span class="word">RUNNING</span>
					<span class="word">CLUB</span>
				</h1>
			</div>
			<div class="scroll-indicator">
				<div class="arrow-down"></div>
			</div>
		</section>

		<!-- Events Section -->
		<section class="events-section">
			<h2 class="section-title">Upcoming Events</h2>
			<div class="events-container">
				{renderedEvents.map((event) => {
					const { Content } = event;
					return (
						<Event 
							title={event.data.title}
							when={event.data.when}
							where={event.data.where}
						>
							<Content />
						</Event>
					);
				})}
			</div>
		</section>

		<Footer />

		<style>
			* {
				margin: 0;
				padding: 0;
				box-sizing: border-box;
			}

			body {
				font-family: "Atkinson", sans-serif;
				background: #000;
				color: #fff;
				overflow-x: hidden;
			}

			/* Hero Section */
			.hero {
				height: 100vh;
				background: #000;
				display: flex;
				flex-direction: column;
				align-items: center;
				justify-content: center;
				position: relative;
			}

			.title-container {
				text-align: center;
			}

			.hero-title {
				font-family: "Lobster", cursive;
				font-size: clamp(3rem, 10vw, 8rem);
				color: #ff1493;
				font-weight: 400;
				line-height: 1.2;
				margin: 0;
			}

			.word {
				display: inline-block;
				margin: 0 0.2em;
				opacity: 0;
			}

			.scroll-indicator {
				position: absolute;
				bottom: 2rem;
				left: 50%;
				transform: translateX(-50%);
			}

			.arrow-down {
				width: 30px;
				height: 30px;
				border-left: 3px solid #ff1493;
				border-bottom: 3px solid #ff1493;
				transform: rotate(-45deg);
				animation: bounce 2s infinite;
			}

			@keyframes bounce {
				0%, 20%, 50%, 80%, 100% {
					transform: translateY(0) rotate(-45deg);
				}
				40% {
					transform: translateY(-10px) rotate(-45deg);
				}
				60% {
					transform: translateY(-5px) rotate(-45deg);
				}
			}

			/* Events Section */
			.events-section {
				min-height: 100vh;
				padding: 4rem 2rem;
				background: linear-gradient(180deg, #000 0%, #1a0a1a 50%, #2d1b2d 100%);
			}

			.section-title {
				font-family: "Lobster", cursive;
				font-size: clamp(2.5rem, 6vw, 5rem);
				color: #ff69b4;
				text-align: center;
				margin-bottom: 3rem;
			}

			.events-container {
				max-width: 1200px;
				margin: 0 auto;
				display: grid;
				grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
				gap: 2rem;
			}

			/* Hover effect: darken all cards when one is hovered */
			.events-container.has-hovered-card :global(.event-card) {
				opacity: 0.4;
				filter: brightness(0.5);
			}

			.events-container.has-hovered-card :global(.event-card.is-hovered) {
				opacity: 1;
				filter: brightness(1);
				transform: translateY(-10px) scale(1.05);
				box-shadow: 0 15px 40px rgba(255, 20, 147, 0.5);
				z-index: 10;
			}

			@media (max-width: 768px) {
				.hero-title {
					font-size: clamp(2rem, 8vw, 6rem);
				}

				.word {
					display: block;
					margin: 0.1em 0;
				}

				.events-section {
					padding: 3rem 1rem;
				}

				.events-container {
					grid-template-columns: 1fr;
				}
			}
		</style>

		<script>
			import { gsap } from 'gsap';

			// Wait for page to load
			document.addEventListener('DOMContentLoaded', () => {
				// Get all words
				const words = document.querySelectorAll('.word');
				let allLetterSpans: HTMLElement[] = [];
				
				// Calculate total animation time
				let maxDelay = 0;
				
				// Animate each word
				words.forEach((word, wordIndex) => {
					const text = word.textContent || '';
					word.textContent = '';
					
					// Split word into individual letters
					const letters = text.split('');
					letters.forEach((letter) => {
						const span = document.createElement('span');
						span.textContent = letter;
						span.style.display = 'inline-block';
						span.style.opacity = '0';
						span.style.cursor = 'default';
						word.appendChild(span);
					});

					// Get all letter spans for this word
					const letterSpans = word.querySelectorAll<HTMLElement>('span');
					
					// Animate letters flying in
					letterSpans.forEach((letter, letterIndex) => {
						const delay = (wordIndex * 0.3) + (letterIndex * 0.05);
						maxDelay = Math.max(maxDelay, delay + 0.8); // track max animation time
						const fromDirection = Math.random() > 0.5 ? -1 : 1;
						
						gsap.fromTo(letter,
							{
								x: fromDirection * 200,
								y: -100,
								opacity: 0,
								rotation: fromDirection * 90
							},
							{
								x: 0,
								y: 0,
								opacity: 1,
								rotation: 0,
								duration: 0.8,
								delay: delay,
								ease: 'back.out(1.7)'
							}
						);
						
						allLetterSpans.push(letter);
					});
				});

				// Show words after letters animate
				gsap.to(words, {
					opacity: 1,
					duration: 0,
					delay: 0
				});

				// Enable physics-based interaction after animation completes + 1 second
				setTimeout(() => {
					enablePhysicsInteraction(allLetterSpans);
				}, (maxDelay + 1) * 1000);

				// Add hover effect for event cards
				const eventCards = document.querySelectorAll('.event-card');
				const eventsContainer = document.querySelector('.events-container');
				
				if (eventsContainer) {
					let hoveredCard = null;
					
					eventCards.forEach((card) => {
						card.addEventListener('mouseenter', () => {
							hoveredCard = card;
							eventsContainer.classList.add('has-hovered-card');
							card.classList.add('is-hovered');
						});
						
						card.addEventListener('mouseleave', () => {
							card.classList.remove('is-hovered');
							hoveredCard = null;
							
							// Only remove container class if no card is currently hovered
							setTimeout(() => {
								if (hoveredCard === null) {
									eventsContainer.classList.remove('has-hovered-card');
								}
							}, 10);
						});
					});
				}
			});

			// Physics-based interaction for letters
			function enablePhysicsInteraction(letters: HTMLElement[]) {
				// Physics constants
				const PUSH_RADIUS = 80;     // Distance at which mouse starts pushing letters
				const PUSH_STRENGTH = 2;    // Force multiplier for push effect
				const GRAVITY = 0.05;       // Downward force (near-zero gravity)
				const DAMPING = 0.99;       // Air resistance coefficient
				const ROTATION_FACTOR = 2;  // How much letters rotate based on velocity

				interface LetterPhysics {
					element: HTMLElement;
					vx: number;  // velocity x
					vy: number;  // velocity y
					x: number;   // accumulated x position
					y: number;   // accumulated y position
				}

				const letterPhysics: LetterPhysics[] = letters.map(letter => {
					return {
						element: letter,
						vx: 0,
						vy: 0,
						x: 0,
						y: 0
					};
				});

				let mouseX = 0;
				let mouseY = 0;

				// Track mouse position
				document.addEventListener('mousemove', (e) => {
					mouseX = e.clientX;
					mouseY = e.clientY;
				});

				// Physics simulation loop
				function updatePhysics() {
					letterPhysics.forEach(letter => {
						const rect = letter.element.getBoundingClientRect();
						const letterCenterX = rect.left + rect.width / 2;
						const letterCenterY = rect.top + rect.height / 2;

						// Calculate distance from mouse to letter
						const dx = letterCenterX - mouseX;
						const dy = letterCenterY - mouseY;
						const distance = Math.sqrt(dx * dx + dy * dy);
						
						if (distance < PUSH_RADIUS && distance > 0) {
							// Apply push force
							const force = (PUSH_RADIUS - distance) / PUSH_RADIUS;
							letter.vx += (dx / distance) * force * PUSH_STRENGTH;
							letter.vy += (dy / distance) * force * PUSH_STRENGTH;
						}

						// Apply gravity
						letter.vy += GRAVITY;

						// Apply air resistance/damping
						letter.vx *= DAMPING;
						letter.vy *= DAMPING;

						// Update accumulated position
						letter.x += letter.vx;
						letter.y += letter.vy;

						// Apply the accumulated transform
						gsap.set(letter.element, {
							x: letter.x,
							y: letter.y,
							rotation: letter.vx * ROTATION_FACTOR,
							force3D: true
						});
					});

					requestAnimationFrame(updatePhysics);
				}

				// Start physics loop
				updatePhysics();
			}
		</script>
	</body>
</html>

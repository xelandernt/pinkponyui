---
import BaseHead from '../components/BaseHead.astro';
import Hero from '../components/Hero.astro';
import EventsSection from '../components/EventsSection.astro';
import NavCircle from '../components/NavCircle.astro';
import Footer from '../components/Footer.astro';
import { getCollection } from 'astro:content';
import {
	SITE_TITLE, 
	LETTER_GRAVITY, 
	MOUSE_PUSH_RADIUS,
	PUSH_STRENGTH,
	DAMPING,
	ROTATION_FACTOR,
	INITIAL_PUSH_MIN,
	INITIAL_PUSH_MAX,
	LETTER_RADIUS,
	COLLISION_DAMPING
} from "../consts";
import '../styles/index.css';

// Get all events from content collection and sort by order
const allEvents = await getCollection('events');
const sortedEvents = allEvents.sort((a, b) => (a.data.order ?? 0) - (b.data.order ?? 0));

// Render all events
const renderedEvents = await Promise.all(
	sortedEvents.map(async (event) => ({
		...event,
		Content: (await event.render()).Content
	}))
);
---

<!doctype html>
<html lang="en">
	<head>
		<BaseHead title={SITE_TITLE} description="Join the Pink Pony Running Club for running events and community fun!" />
	</head>
	<body>
		<div class="page-wrapper">
			<NavCircle position="top-right" href="/blog" text="Blog" />
			<Hero />
			<EventsSection renderedEvents={renderedEvents} />
			<Footer />
		</div>

		<script is:inline define:vars={{
			LETTER_GRAVITY, 
			MOUSE_PUSH_RADIUS,
			PUSH_STRENGTH,
			DAMPING,
			ROTATION_FACTOR,
			INITIAL_PUSH_MIN,
			INITIAL_PUSH_MAX,
			LETTER_RADIUS,
			COLLISION_DAMPING
		}}>
			// Physics constants from consts.ts are now available as variables
			window.LETTER_GRAVITY = LETTER_GRAVITY;
			window.MOUSE_PUSH_RADIUS = MOUSE_PUSH_RADIUS;
			window.PUSH_STRENGTH = PUSH_STRENGTH;
			window.DAMPING = DAMPING;
			window.ROTATION_FACTOR = ROTATION_FACTOR;
			window.INITIAL_PUSH_MIN = INITIAL_PUSH_MIN;
			window.INITIAL_PUSH_MAX = INITIAL_PUSH_MAX;
			window.LETTER_RADIUS = LETTER_RADIUS;
			window.COLLISION_DAMPING = COLLISION_DAMPING;
		</script>

		<script>
			import { gsap } from 'gsap';

			// Get physics constants from window
			const LETTER_GRAVITY = window.LETTER_GRAVITY;
			const MOUSE_PUSH_RADIUS = window.MOUSE_PUSH_RADIUS;
			const PUSH_STRENGTH = window.PUSH_STRENGTH;
			const DAMPING = window.DAMPING;
			const ROTATION_FACTOR = window.ROTATION_FACTOR;
			const INITIAL_PUSH_MIN = window.INITIAL_PUSH_MIN;
			const INITIAL_PUSH_MAX = window.INITIAL_PUSH_MAX;
			const LETTER_RADIUS = window.LETTER_RADIUS;
			const COLLISION_DAMPING = window.COLLISION_DAMPING;

			// Wait for page to load
			document.addEventListener('DOMContentLoaded', () => {
				// Get all words
				const words = document.querySelectorAll('.word');
				let allLetterSpans: HTMLElement[] = [];
				
				// Calculate total animation time
				let maxDelay = 0;
				
				// Animate each word
				words.forEach((word, wordIndex) => {
					const text = word.textContent || '';
					word.textContent = '';
					
					// Split word into individual letters
					const letters = text.split('');
					letters.forEach((letter) => {
						const span = document.createElement('span');
						span.textContent = letter;
						span.style.display = 'inline-block';
						span.style.opacity = '0';
						span.style.cursor = 'default';
						word.appendChild(span);
					});

					// Get all letter spans for this word
					const letterSpans = word.querySelectorAll<HTMLElement>('span');
					
					// Animate letters flying in
					letterSpans.forEach((letter, letterIndex) => {
						const delay = (wordIndex * 0.3) + (letterIndex * 0.05);
						maxDelay = Math.max(maxDelay, delay + 0.8); // track max animation time
						const fromDirection = Math.random() > 0.5 ? -1 : 1;
						
						gsap.fromTo(letter,
							{
								x: fromDirection * 200,
								y: -100,
								opacity: 0,
								rotation: fromDirection * 90
							},
							{
								x: 0,
								y: 0,
								opacity: 1,
								rotation: 0,
								duration: 0.8,
								delay: delay,
								ease: 'back.out(1.7)'
							}
						);
						
						allLetterSpans.push(letter);
					});
				});

				// Show words after letters animate
				gsap.to(words, {
					opacity: 1,
					duration: 0,
					delay: 0
				});

				// Enable physics-based interaction after animation completes + 1 second
				setTimeout(() => {
					enablePhysicsInteraction(allLetterSpans);
				}, (maxDelay + 1) * 1000);

				// Add hover effect for event cards
				const eventCards = document.querySelectorAll('.event-card');
				const eventsContainer = document.querySelector('.events-container');
				
				if (eventsContainer) {
					let hoveredCard = null;
					
					eventCards.forEach((card) => {
						card.addEventListener('mouseenter', () => {
							hoveredCard = card;
							eventsContainer.classList.add('has-hovered-card');
							card.classList.add('is-hovered');
						});
						
						card.addEventListener('mouseleave', () => {
							card.classList.remove('is-hovered');
							hoveredCard = null;
							
							// Only remove container class if no card is currently hovered
							setTimeout(() => {
								if (hoveredCard === null) {
									eventsContainer.classList.remove('has-hovered-card');
								}
							}, 10);
						});
					});
				}
			});

			// Physics-based interaction for letters
			function enablePhysicsInteraction(letters: HTMLElement[]) {
				// Physics constants are now imported from consts.ts
				const PUSH_RADIUS = MOUSE_PUSH_RADIUS;     // Distance at which mouse starts pushing letters
				const GRAVITY = LETTER_GRAVITY;            // Downward force (near-zero gravity)

				interface LetterPhysics {
					element: HTMLElement;
					vx: number;  // velocity x
					vy: number;  // velocity y
					x: number;   // accumulated x position
					y: number;   // accumulated y position
					radius: number; // collision radius
				}

				const letterPhysics: LetterPhysics[] = letters.map(letter => {
					// Give each letter a random initial push in a random direction
					const randomVx = INITIAL_PUSH_MIN + Math.random() * (INITIAL_PUSH_MAX - INITIAL_PUSH_MIN);
					const randomVy = INITIAL_PUSH_MIN + Math.random() * (INITIAL_PUSH_MAX - INITIAL_PUSH_MIN);
					
					// Get current position and computed styles before converting
					const rect = letter.getBoundingClientRect();
					const computedStyle = window.getComputedStyle(letter);
					
					// Hide original letter (keeps layout intact)
					letter.style.opacity = '0';
					letter.style.pointerEvents = 'none';
					
					// Create fixed positioned clone for physics (stays in viewport position)
					const clone = letter.cloneNode(true) as HTMLElement;
					clone.style.position = 'fixed';
					clone.style.left = rect.left + 'px';
					clone.style.top = rect.top + 'px';
					clone.style.width = rect.width + 'px';
					clone.style.height = rect.height + 'px';
					clone.style.margin = '0';
					clone.style.opacity = '1';
					clone.style.pointerEvents = 'none';
					
					// Copy critical computed styles to preserve appearance
					clone.style.fontSize = computedStyle.fontSize;
					clone.style.fontFamily = computedStyle.fontFamily;
					clone.style.fontWeight = computedStyle.fontWeight;
					clone.style.color = computedStyle.color;
					clone.style.display = 'inline-block';
					
					// Append to body for fixed positioning
					document.body.appendChild(clone);
					
					return {
						element: clone,
						vx: randomVx,
						vy: randomVy,
						x: 0,
						y: 0,
						radius: LETTER_RADIUS
					};
				});

				let mouseX = 0;
				let mouseY = 0;
				
				// Track scroll position to adjust letter positions
				const wrapper = document.querySelector('.page-wrapper');
				const initialScrollY = wrapper?.scrollTop || 0;
				let currentScrollY = initialScrollY;
				
				// Update scroll position
				wrapper?.addEventListener('scroll', () => {
					currentScrollY = wrapper.scrollTop || 0;
				});

				// Track mouse position
				document.addEventListener('mousemove', (e) => {
					mouseX = e.clientX;
					mouseY = e.clientY;
				});

				// Physics simulation loop
				function updatePhysics() {
					// Calculate scroll offset from initial position
					const scrollDelta = currentScrollY - initialScrollY;
					
					letterPhysics.forEach(letter => {
						const rect = letter.element.getBoundingClientRect();
						const letterCenterX = rect.left + rect.width / 2;
						const letterCenterY = rect.top + rect.height / 2;

						// Calculate distance from mouse to letter
						const dx = letterCenterX - mouseX;
						const dy = letterCenterY - mouseY;
						const distance = Math.sqrt(dx * dx + dy * dy);
						
						if (distance < PUSH_RADIUS && distance > 0) {
							// Apply push force
							const force = (PUSH_RADIUS - distance) / PUSH_RADIUS;
							letter.vx += (dx / distance) * force * PUSH_STRENGTH;
							letter.vy += (dy / distance) * force * PUSH_STRENGTH;
						}

						// Apply gravity
						letter.vy += GRAVITY;

						// Apply air resistance/damping
						letter.vx *= DAMPING;
						letter.vy *= DAMPING;

						// Update accumulated position
						letter.x += letter.vx;
						letter.y += letter.vy;

						// Apply the accumulated transform, adjusted for scroll
						// Subtract scrollDelta so letters move "up" when scrolling down
						gsap.set(letter.element, {
							x: letter.x,
							y: letter.y - scrollDelta,
							rotation: letter.vx * ROTATION_FACTOR,
							force3D: true
						});
					});

					// Check for collisions between letters
					for (let i = 0; i < letterPhysics.length; i++) {
						for (let j = i + 1; j < letterPhysics.length; j++) {
							const letter1 = letterPhysics[i];
							const letter2 = letterPhysics[j];
							
							// Get current positions including transforms
							const rect1 = letter1.element.getBoundingClientRect();
							const rect2 = letter2.element.getBoundingClientRect();
							
							const center1X = rect1.left + rect1.width / 2;
							const center1Y = rect1.top + rect1.height / 2;
							const center2X = rect2.left + rect2.width / 2;
							const center2Y = rect2.top + rect2.height / 2;
							
							const dx = center2X - center1X;
							const dy = center2Y - center1Y;
							const distance = Math.sqrt(dx * dx + dy * dy);
							const minDistance = letter1.radius + letter2.radius;
							
							// Check if letters are colliding
							if (distance < minDistance && distance > 0) {
								// Calculate collision normal
								const nx = dx / distance;
								const ny = dy / distance;
								
								// Separate letters
								const overlap = minDistance - distance;
								const separationX = nx * overlap * 0.5;
								const separationY = ny * overlap * 0.5;
								
								letter1.x -= separationX;
								letter1.y -= separationY;
								letter2.x += separationX;
								letter2.y += separationY;
								
								// Calculate relative velocity
								const dvx = letter2.vx - letter1.vx;
								const dvy = letter2.vy - letter1.vy;
								
								// Calculate relative velocity in collision normal direction
								const dvn = dvx * nx + dvy * ny;
								
								// Do not resolve if velocities are separating
								if (dvn < 0) {
									// Calculate impulse scalar
									const impulse = dvn * COLLISION_DAMPING;
									
									// Apply impulse to velocities
									letter1.vx += impulse * nx;
									letter1.vy += impulse * ny;
									letter2.vx -= impulse * nx;
									letter2.vy -= impulse * ny;
								}
							}
						}
					}

					requestAnimationFrame(updatePhysics);
				}

				// Start physics loop
				updatePhysics();
			}
		</script>
	</body>
</html>
